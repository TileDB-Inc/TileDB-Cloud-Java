/*
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.tiledb.cloud.rest_api.v2.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;

import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

import io.tiledb.cloud.rest_api.v2.JSON;

/**
 * A union type which may contain a credential to access any one cloud provider.
 */
@ApiModel(description = "A union type which may contain a credential to access any one cloud provider.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-07-02T18:54:48.746612+03:00[Europe/Athens]")
public class AccessCredential {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PROVIDER = "provider";
  @SerializedName(SERIALIZED_NAME_PROVIDER)
  private CloudProvider provider;

  public static final String SERIALIZED_NAME_PROVIDER_DEFAULT = "provider_default";
  @SerializedName(SERIALIZED_NAME_PROVIDER_DEFAULT)
  private Boolean providerDefault;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_ALLOWED_IN_TASKS = "allowed_in_tasks";
  @SerializedName(SERIALIZED_NAME_ALLOWED_IN_TASKS)
  private Boolean allowedInTasks;

  public static final String SERIALIZED_NAME_CREDENTIAL = "credential";
  @SerializedName(SERIALIZED_NAME_CREDENTIAL)
  private AccessCredentialCredential credential;

  public static final String SERIALIZED_NAME_ROLE = "role";
  @SerializedName(SERIALIZED_NAME_ROLE)
  private AccessCredentialRole role;

  public static final String SERIALIZED_NAME_TOKEN = "token";
  @SerializedName(SERIALIZED_NAME_TOKEN)
  private AccessCredentialToken token;

  public AccessCredential() { 
  }

  
  public AccessCredential(
     OffsetDateTime createdAt, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }

  public AccessCredential name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * A user-specified name for the key
   * @return name
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A user-specified name for the key")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public AccessCredential provider(CloudProvider provider) {
    
    this.provider = provider;
    return this;
  }

   /**
   * Get provider
   * @return provider
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CloudProvider getProvider() {
    return provider;
  }


  public void setProvider(CloudProvider provider) {
    this.provider = provider;
  }


  public AccessCredential providerDefault(Boolean providerDefault) {
    
    this.providerDefault = providerDefault;
    return this;
  }

   /**
   * True if this is the namespace&#39;s default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider.
   * @return providerDefault
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "True if this is the namespace's default credential to be used when connecting to the given cloud provider. There can be at most one default for each unique provider.")

  public Boolean getProviderDefault() {
    return providerDefault;
  }


  public void setProviderDefault(Boolean providerDefault) {
    this.providerDefault = providerDefault;
  }


   /**
   * Time when the credential was created (rfc3339)
   * @return createdAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Time when the credential was created (rfc3339)")

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }




   /**
   * Time when the credential was last updated (rfc3339)
   * @return updatedAt
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Time when the credential was last updated (rfc3339)")

  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }




  public AccessCredential allowedInTasks(Boolean allowedInTasks) {
    
    this.allowedInTasks = allowedInTasks;
    return this;
  }

   /**
   * Is this credential allowed to be used in tasks
   * @return allowedInTasks
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Is this credential allowed to be used in tasks")

  public Boolean getAllowedInTasks() {
    return allowedInTasks;
  }


  public void setAllowedInTasks(Boolean allowedInTasks) {
    this.allowedInTasks = allowedInTasks;
  }


  public AccessCredential credential(AccessCredentialCredential credential) {
    
    this.credential = credential;
    return this;
  }

   /**
   * Get credential
   * @return credential
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public AccessCredentialCredential getCredential() {
    return credential;
  }


  public void setCredential(AccessCredentialCredential credential) {
    this.credential = credential;
  }


  public AccessCredential role(AccessCredentialRole role) {
    
    this.role = role;
    return this;
  }

   /**
   * Get role
   * @return role
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public AccessCredentialRole getRole() {
    return role;
  }


  public void setRole(AccessCredentialRole role) {
    this.role = role;
  }


  public AccessCredential token(AccessCredentialToken token) {
    
    this.token = token;
    return this;
  }

   /**
   * Get token
   * @return token
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public AccessCredentialToken getToken() {
    return token;
  }


  public void setToken(AccessCredentialToken token) {
    this.token = token;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   */
  public AccessCredential putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AccessCredential accessCredential = (AccessCredential) o;
    return Objects.equals(this.name, accessCredential.name) &&
        Objects.equals(this.provider, accessCredential.provider) &&
        Objects.equals(this.providerDefault, accessCredential.providerDefault) &&
        Objects.equals(this.createdAt, accessCredential.createdAt) &&
        Objects.equals(this.updatedAt, accessCredential.updatedAt) &&
        Objects.equals(this.allowedInTasks, accessCredential.allowedInTasks) &&
        Objects.equals(this.credential, accessCredential.credential) &&
        Objects.equals(this.role, accessCredential.role) &&
        Objects.equals(this.token, accessCredential.token)&&
        Objects.equals(this.additionalProperties, accessCredential.additionalProperties);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, provider, providerDefault, createdAt, updatedAt, allowedInTasks, credential, role, token, additionalProperties);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AccessCredential {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    provider: ").append(toIndentedString(provider)).append("\n");
    sb.append("    providerDefault: ").append(toIndentedString(providerDefault)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    allowedInTasks: ").append(toIndentedString(allowedInTasks)).append("\n");
    sb.append("    credential: ").append(toIndentedString(credential)).append("\n");
    sb.append("    role: ").append(toIndentedString(role)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("provider");
    openapiFields.add("provider_default");
    openapiFields.add("created_at");
    openapiFields.add("updated_at");
    openapiFields.add("allowed_in_tasks");
    openapiFields.add("credential");
    openapiFields.add("role");
    openapiFields.add("token");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to AccessCredential
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (AccessCredential.openapiRequiredFields.isEmpty()) {
          return;
        } else { // has required fields
          throw new IllegalArgumentException(String.format("The required field(s) %s in AccessCredential is not found in the empty JSON string", AccessCredential.openapiRequiredFields.toString()));
        }
      }
      if (jsonObj.get("name") != null && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `credential`
      if (jsonObj.getAsJsonObject("credential") != null) {
        AccessCredentialCredential.validateJsonObject(jsonObj.getAsJsonObject("credential"));
      }
      // validate the optional field `role`
      if (jsonObj.getAsJsonObject("role") != null) {
        AccessCredentialRole.validateJsonObject(jsonObj.getAsJsonObject("role"));
      }
      // validate the optional field `token`
      if (jsonObj.getAsJsonObject("token") != null) {
        AccessCredentialToken.validateJsonObject(jsonObj.getAsJsonObject("token"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AccessCredential.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AccessCredential' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AccessCredential> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AccessCredential.class));

       return (TypeAdapter<T>) new TypeAdapter<AccessCredential>() {
           @Override
           public void write(JsonWriter out, AccessCredential value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public AccessCredential read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             AccessCredential instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else { // non-primitive type
                   instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of AccessCredential given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of AccessCredential
  * @throws IOException if the JSON string is invalid with respect to AccessCredential
  */
  public static AccessCredential fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AccessCredential.class);
  }

 /**
  * Convert an instance of AccessCredential to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

