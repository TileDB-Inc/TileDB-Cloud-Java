/*
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.17.51
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.tiledb.cloud.rest_api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.tiledb.cloud.rest_api.model.RetryStrategy;
import io.tiledb.cloud.rest_api.model.TGInputNodeData;
import io.tiledb.cloud.rest_api.model.TGSQLNodeData;
import io.tiledb.cloud.rest_api.model.TGUDFNodeData;
import io.tiledb.cloud.rest_api.model.UDFArrayDetails;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import io.tiledb.cloud.rest_api.JSON;

/**
 * Information about a single node within a registered task graph. A single node represents one piece of data or a computational step; either as an input value, a data source, or a computation that acts upon earlier nodes. The structure parallels the existing &#x60;TaskGraphNodeMetadata&#x60;. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.7.0")
public class TaskGraphNode {
  public static final String SERIALIZED_NAME_CLIENT_NODE_ID = "client_node_id";
  @SerializedName(SERIALIZED_NAME_CLIENT_NODE_ID)
  private String clientNodeId;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_DEPENDS_ON = "depends_on";
  @SerializedName(SERIALIZED_NAME_DEPENDS_ON)
  private List<String> dependsOn = new ArrayList<>();

  public static final String SERIALIZED_NAME_ARRAY_NODE = "array_node";
  @SerializedName(SERIALIZED_NAME_ARRAY_NODE)
  private UDFArrayDetails arrayNode;

  public static final String SERIALIZED_NAME_INPUT_NODE = "input_node";
  @SerializedName(SERIALIZED_NAME_INPUT_NODE)
  private TGInputNodeData inputNode;

  public static final String SERIALIZED_NAME_SQL_NODE = "sql_node";
  @SerializedName(SERIALIZED_NAME_SQL_NODE)
  private TGSQLNodeData sqlNode;

  public static final String SERIALIZED_NAME_UDF_NODE = "udf_node";
  @SerializedName(SERIALIZED_NAME_UDF_NODE)
  private TGUDFNodeData udfNode;

  public static final String SERIALIZED_NAME_RETRY_STRATEGY = "retry_strategy";
  @SerializedName(SERIALIZED_NAME_RETRY_STRATEGY)
  private RetryStrategy retryStrategy;

  public static final String SERIALIZED_NAME_EXPAND_NODE_OUTPUT = "expand_node_output";
  @SerializedName(SERIALIZED_NAME_EXPAND_NODE_OUTPUT)
  private String expandNodeOutput;

  public static final String SERIALIZED_NAME_DEADLINE = "deadline";
  @SerializedName(SERIALIZED_NAME_DEADLINE)
  private Long deadline;

  public TaskGraphNode() {
  }

  public TaskGraphNode clientNodeId(String clientNodeId) {
    this.clientNodeId = clientNodeId;
    return this;
  }

  /**
   * The client-generated UUID of the given graph node.
   * @return clientNodeId
   */
  @javax.annotation.Nullable
  public String getClientNodeId() {
    return clientNodeId;
  }

  public void setClientNodeId(String clientNodeId) {
    this.clientNodeId = clientNodeId;
  }


  public TaskGraphNode name(String name) {
    this.name = name;
    return this;
  }

  /**
   * A client-specified name for the node. If provided, this must be unique. 
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public TaskGraphNode dependsOn(List<String> dependsOn) {
    this.dependsOn = dependsOn;
    return this;
  }

  public TaskGraphNode addDependsOnItem(String dependsOnItem) {
    if (this.dependsOn == null) {
      this.dependsOn = new ArrayList<>();
    }
    this.dependsOn.add(dependsOnItem);
    return this;
  }

  /**
   * The client_node_uuid of each node that this node depends upon. Used to define the structure of the graph. 
   * @return dependsOn
   */
  @javax.annotation.Nullable
  public List<String> getDependsOn() {
    return dependsOn;
  }

  public void setDependsOn(List<String> dependsOn) {
    this.dependsOn = dependsOn;
  }


  public TaskGraphNode arrayNode(UDFArrayDetails arrayNode) {
    this.arrayNode = arrayNode;
    return this;
  }

  /**
   * Get arrayNode
   * @return arrayNode
   */
  @javax.annotation.Nullable
  public UDFArrayDetails getArrayNode() {
    return arrayNode;
  }

  public void setArrayNode(UDFArrayDetails arrayNode) {
    this.arrayNode = arrayNode;
  }


  public TaskGraphNode inputNode(TGInputNodeData inputNode) {
    this.inputNode = inputNode;
    return this;
  }

  /**
   * Get inputNode
   * @return inputNode
   */
  @javax.annotation.Nullable
  public TGInputNodeData getInputNode() {
    return inputNode;
  }

  public void setInputNode(TGInputNodeData inputNode) {
    this.inputNode = inputNode;
  }


  public TaskGraphNode sqlNode(TGSQLNodeData sqlNode) {
    this.sqlNode = sqlNode;
    return this;
  }

  /**
   * Get sqlNode
   * @return sqlNode
   */
  @javax.annotation.Nullable
  public TGSQLNodeData getSqlNode() {
    return sqlNode;
  }

  public void setSqlNode(TGSQLNodeData sqlNode) {
    this.sqlNode = sqlNode;
  }


  public TaskGraphNode udfNode(TGUDFNodeData udfNode) {
    this.udfNode = udfNode;
    return this;
  }

  /**
   * Get udfNode
   * @return udfNode
   */
  @javax.annotation.Nullable
  public TGUDFNodeData getUdfNode() {
    return udfNode;
  }

  public void setUdfNode(TGUDFNodeData udfNode) {
    this.udfNode = udfNode;
  }


  public TaskGraphNode retryStrategy(RetryStrategy retryStrategy) {
    this.retryStrategy = retryStrategy;
    return this;
  }

  /**
   * Get retryStrategy
   * @return retryStrategy
   */
  @javax.annotation.Nullable
  public RetryStrategy getRetryStrategy() {
    return retryStrategy;
  }

  public void setRetryStrategy(RetryStrategy retryStrategy) {
    this.retryStrategy = retryStrategy;
  }


  public TaskGraphNode expandNodeOutput(String expandNodeOutput) {
    this.expandNodeOutput = expandNodeOutput;
    return this;
  }

  /**
   * Used to create dynamic tasks based on the output of another node. The other node&#39;s output must be a JSON list of values. The expansion process creates one task per item in the output list. The item is also passed as an argument to each task. The value is the client_node_uuid of the node that we want to expand. 
   * @return expandNodeOutput
   */
  @javax.annotation.Nullable
  public String getExpandNodeOutput() {
    return expandNodeOutput;
  }

  public void setExpandNodeOutput(String expandNodeOutput) {
    this.expandNodeOutput = expandNodeOutput;
  }


  public TaskGraphNode deadline(Long deadline) {
    this.deadline = deadline;
    return this;
  }

  /**
   * Duration in seconds relative to the node start time which the node is allowed to run before it gets terminated. 
   * @return deadline
   */
  @javax.annotation.Nullable
  public Long getDeadline() {
    return deadline;
  }

  public void setDeadline(Long deadline) {
    this.deadline = deadline;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TaskGraphNode taskGraphNode = (TaskGraphNode) o;
    return Objects.equals(this.clientNodeId, taskGraphNode.clientNodeId) &&
        Objects.equals(this.name, taskGraphNode.name) &&
        Objects.equals(this.dependsOn, taskGraphNode.dependsOn) &&
        Objects.equals(this.arrayNode, taskGraphNode.arrayNode) &&
        Objects.equals(this.inputNode, taskGraphNode.inputNode) &&
        Objects.equals(this.sqlNode, taskGraphNode.sqlNode) &&
        Objects.equals(this.udfNode, taskGraphNode.udfNode) &&
        Objects.equals(this.retryStrategy, taskGraphNode.retryStrategy) &&
        Objects.equals(this.expandNodeOutput, taskGraphNode.expandNodeOutput) &&
        Objects.equals(this.deadline, taskGraphNode.deadline);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientNodeId, name, dependsOn, arrayNode, inputNode, sqlNode, udfNode, retryStrategy, expandNodeOutput, deadline);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TaskGraphNode {\n");
    sb.append("    clientNodeId: ").append(toIndentedString(clientNodeId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    dependsOn: ").append(toIndentedString(dependsOn)).append("\n");
    sb.append("    arrayNode: ").append(toIndentedString(arrayNode)).append("\n");
    sb.append("    inputNode: ").append(toIndentedString(inputNode)).append("\n");
    sb.append("    sqlNode: ").append(toIndentedString(sqlNode)).append("\n");
    sb.append("    udfNode: ").append(toIndentedString(udfNode)).append("\n");
    sb.append("    retryStrategy: ").append(toIndentedString(retryStrategy)).append("\n");
    sb.append("    expandNodeOutput: ").append(toIndentedString(expandNodeOutput)).append("\n");
    sb.append("    deadline: ").append(toIndentedString(deadline)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("client_node_id");
    openapiFields.add("name");
    openapiFields.add("depends_on");
    openapiFields.add("array_node");
    openapiFields.add("input_node");
    openapiFields.add("sql_node");
    openapiFields.add("udf_node");
    openapiFields.add("retry_strategy");
    openapiFields.add("expand_node_output");
    openapiFields.add("deadline");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TaskGraphNode
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TaskGraphNode.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TaskGraphNode is not found in the empty JSON string", TaskGraphNode.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TaskGraphNode.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TaskGraphNode` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("client_node_id") != null && !jsonObj.get("client_node_id").isJsonNull()) && !jsonObj.get("client_node_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_node_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_node_id").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("depends_on") != null && !jsonObj.get("depends_on").isJsonNull() && !jsonObj.get("depends_on").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `depends_on` to be an array in the JSON string but got `%s`", jsonObj.get("depends_on").toString()));
      }
      // validate the optional field `array_node`
      if (jsonObj.get("array_node") != null && !jsonObj.get("array_node").isJsonNull()) {
        UDFArrayDetails.validateJsonElement(jsonObj.get("array_node"));
      }
      // validate the optional field `input_node`
      if (jsonObj.get("input_node") != null && !jsonObj.get("input_node").isJsonNull()) {
        TGInputNodeData.validateJsonElement(jsonObj.get("input_node"));
      }
      // validate the optional field `sql_node`
      if (jsonObj.get("sql_node") != null && !jsonObj.get("sql_node").isJsonNull()) {
        TGSQLNodeData.validateJsonElement(jsonObj.get("sql_node"));
      }
      // validate the optional field `udf_node`
      if (jsonObj.get("udf_node") != null && !jsonObj.get("udf_node").isJsonNull()) {
        TGUDFNodeData.validateJsonElement(jsonObj.get("udf_node"));
      }
      // validate the optional field `retry_strategy`
      if (jsonObj.get("retry_strategy") != null && !jsonObj.get("retry_strategy").isJsonNull()) {
        RetryStrategy.validateJsonElement(jsonObj.get("retry_strategy"));
      }
      if ((jsonObj.get("expand_node_output") != null && !jsonObj.get("expand_node_output").isJsonNull()) && !jsonObj.get("expand_node_output").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expand_node_output` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expand_node_output").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TaskGraphNode.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TaskGraphNode' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TaskGraphNode> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TaskGraphNode.class));

       return (TypeAdapter<T>) new TypeAdapter<TaskGraphNode>() {
           @Override
           public void write(JsonWriter out, TaskGraphNode value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TaskGraphNode read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TaskGraphNode given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TaskGraphNode
   * @throws IOException if the JSON string is invalid with respect to TaskGraphNode
   */
  public static TaskGraphNode fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TaskGraphNode.class);
  }

  /**
   * Convert an instance of TaskGraphNode to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

